<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Go：GMP模型深入理解 | 小小程知识库</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="https://cdn-static.xxcheng.cn/static/public/logo/64_64.ico">
    <meta name="description" content="个人总结知识库,专注前端、Golang">
    <meta name="keywords" content="xxcheng知识库,小小程知识库,知识库,前端知识库,Golang知识库,前端,前端开发,前端框架,web前端,技术文档,学习,JavaScript,js,ES6,TypeScript,vue,golang,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="z3ADKJ0W8g">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.bf945c37.css" as="style"><link rel="preload" href="/assets/js/app.93b3f0b1.js" as="script"><link rel="preload" href="/assets/js/2.aec7a7f0.js" as="script"><link rel="preload" href="/assets/js/14.eebbe75b.js" as="script"><link rel="prefetch" href="/assets/js/10.300e00aa.js"><link rel="prefetch" href="/assets/js/11.0e98b3ed.js"><link rel="prefetch" href="/assets/js/12.6f626e41.js"><link rel="prefetch" href="/assets/js/13.d0c640b1.js"><link rel="prefetch" href="/assets/js/15.b16a109f.js"><link rel="prefetch" href="/assets/js/16.9f2e200b.js"><link rel="prefetch" href="/assets/js/17.142a03c6.js"><link rel="prefetch" href="/assets/js/18.cd8ac442.js"><link rel="prefetch" href="/assets/js/19.487fc2bb.js"><link rel="prefetch" href="/assets/js/20.3cb2c94c.js"><link rel="prefetch" href="/assets/js/21.8ccae75c.js"><link rel="prefetch" href="/assets/js/22.aeababc9.js"><link rel="prefetch" href="/assets/js/23.bb235707.js"><link rel="prefetch" href="/assets/js/24.a45213d4.js"><link rel="prefetch" href="/assets/js/25.695efc2d.js"><link rel="prefetch" href="/assets/js/26.6e0dcbe0.js"><link rel="prefetch" href="/assets/js/27.1a3008d3.js"><link rel="prefetch" href="/assets/js/28.c84eaeb6.js"><link rel="prefetch" href="/assets/js/29.5b4cfd9b.js"><link rel="prefetch" href="/assets/js/3.8522f2e0.js"><link rel="prefetch" href="/assets/js/30.02405b51.js"><link rel="prefetch" href="/assets/js/31.0de66001.js"><link rel="prefetch" href="/assets/js/32.f35acc80.js"><link rel="prefetch" href="/assets/js/33.1265ba71.js"><link rel="prefetch" href="/assets/js/34.a18cf05a.js"><link rel="prefetch" href="/assets/js/35.479f7270.js"><link rel="prefetch" href="/assets/js/36.9f67f7ae.js"><link rel="prefetch" href="/assets/js/37.80172425.js"><link rel="prefetch" href="/assets/js/38.f1e60099.js"><link rel="prefetch" href="/assets/js/39.ac180027.js"><link rel="prefetch" href="/assets/js/4.b2ea6df6.js"><link rel="prefetch" href="/assets/js/40.d00d1f40.js"><link rel="prefetch" href="/assets/js/5.f0502413.js"><link rel="prefetch" href="/assets/js/6.c2d1667e.js"><link rel="prefetch" href="/assets/js/7.7a24b5ef.js"><link rel="prefetch" href="/assets/js/8.50820b2d.js"><link rel="prefetch" href="/assets/js/9.65fae3ee.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bf945c37.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://cdn-static.xxcheng.cn/static/public/logo/640_640.png" alt="小小程知识库" class="logo"> <span class="site-name can-hide">小小程知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/golang/" class="nav-link">Golang</a></div><div class="nav-item"><a href="/mysql/" class="nav-link">MySQL</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/xxcheng123/xxcheng-repository" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn-static.xxcheng.cn/static/public/logo/640_640.png"> <div class="blogger-info"><h3>xxcheng</h3> <span>记录美好生活~</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/golang/" class="nav-link">Golang</a></div><div class="nav-item"><a href="/mysql/" class="nav-link">MySQL</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div> <a href="https://github.com/xxcheng123/xxcheng-repository" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>语言基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>GORM 框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>go-zero 微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>专题学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/82ad4c/" class="sidebar-link">rpc学习：进阶到gRPC</a></li><li><a href="/pages/bc0f7f/" aria-current="page" class="active sidebar-link">Go：GMP模型深入理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/bc0f7f/#一、基础知识学习" class="sidebar-link">一、基础知识学习</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_1-1-概述" class="sidebar-link">1.1 概述</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_1-2-进程和线程" class="sidebar-link">1.2 进程和线程</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_1-3-内核态和用户态" class="sidebar-link">1.3 内核态和用户态</a></li><li class="sidebar-sub-header level5"><a href="/pages/bc0f7f/#系统调用-using-syscalls" class="sidebar-link">系统调用（using syscalls）</a></li><li class="sidebar-sub-header level5"><a href="/pages/bc0f7f/#库函数" class="sidebar-link">库函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#shell" class="sidebar-link">Shell</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_1-4-线程和协程映射关系" class="sidebar-link">1.4 线程和协程映射关系</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_1-5-goroutine" class="sidebar-link">1.5 goroutine</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/bc0f7f/#二、gmp-调度器模型" class="sidebar-link">二、GMP 调度器模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_2-1-早期的-gm-模型" class="sidebar-link">2.1 早期的 GM 模型</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_2-2-gmp-模型" class="sidebar-link">2.2 GMP 模型</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_2-3-设计策略" class="sidebar-link">2.3 设计策略</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_1-复用策略" class="sidebar-link">1. 复用策略</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_2-利用并行" class="sidebar-link">2. 利用并行</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-抢占" class="sidebar-link">3. 抢占</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_4-全局队列" class="sidebar-link">4. 全局队列</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_2-4-go-func-执行流程" class="sidebar-link">2.4 go func 执行流程</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_2-5-生命周期" class="sidebar-link">2.5 生命周期</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/bc0f7f/#三、执行过程分析" class="sidebar-link">三、执行过程分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_3-1-g1-创建-g2" class="sidebar-link">3.1 G1 创建 G2</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-1-1-本队队列空间足够" class="sidebar-link">3.1.1 本队队列空间足够</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-1-2-本地队列空间不足" class="sidebar-link">3.1.2 本地队列空间不足</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_3-2-g0-调度" class="sidebar-link">3.2 G0 调度</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-2-1-本地队列有空闲-g" class="sidebar-link">3.2.1 本地队列有空闲 G</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-2-2-全局队列获取空闲-g" class="sidebar-link">3.2.2 全局队列获取空闲 G</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-2-3-全局队列也没有空闲的-g" class="sidebar-link">3.2.3 全局队列也没有空闲的 G</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-2-4-没有空闲的-g" class="sidebar-link">3.2.4 没有空闲的 G</a></li><li class="sidebar-sub-header level4"><a href="/pages/bc0f7f/#_3-2-4-网络轮旋" class="sidebar-link">3.2.4 网络轮旋</a></li><li class="sidebar-sub-header level3"><a href="/pages/bc0f7f/#_3-3-系统调用-syscall" class="sidebar-link">3.3 系统调用（syscall）</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/bc0f7f/#四、参考" class="sidebar-link">四、参考</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>未整理的学习笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/golang/#Golang" data-v-06225672>Golang</a></li><li data-v-06225672><a href="/golang/#专题学习" data-v-06225672>专题学习</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://www.xxcheng.cn/" target="_blank" title="作者" class="beLink" data-v-06225672>xxcheng</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-01-10</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Go：GMP模型深入理解<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="一、基础知识学习"><a href="#一、基础知识学习" class="header-anchor">#</a> 一、基础知识学习</h2> <h3 id="_1-1-概述"><a href="#_1-1-概述" class="header-anchor">#</a> 1.1 概述</h3> <p>计算机最早是时候是单进程时代，一次只能执行一个进程任务，其他进程想执行任务，只能等待排队。</p> <p>后面出现了多进程、多线程，可以同时执行多个进程/线程任务，但是这个是并非真正的同时执行。而是将CPU的执行时间切分成一个个时间单位（时间片），然后将这些进程/线程切换着执行。</p> <p>如果一个进程资源很大，那么这个进程的创建、销毁、切换都会占用很大的时间，切换时会有切换成本。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ca3f3f0a400000.png" alt="image-20240105100805883"></p> <h3 id="_1-2-进程和线程"><a href="#_1-2-进程和线程" class="header-anchor">#</a> 1.2 进程和线程</h3> <p>进程是<strong>资源分配</strong>的基本单位，线程是<strong>调度和执行</strong>的基本单位，一个进程下的多个线程共享内存资源，可以互相访问。但是多线程也存在着很多的问题：锁、资源竞争、同步。</p> <h3 id="_1-3-内核态和用户态"><a href="#_1-3-内核态和用户态" class="header-anchor">#</a> 1.3 内核态和用户态</h3> <p>这个知识点的概念我还是很模糊，只能结合几篇文章后来尝试表达我的理解。</p> <p>首先<strong>内核态（Kernel Mode）<strong>和</strong>用户态的（User Mode）<strong>主要的区别是执行的权限的不同，用户态可执行的权限小，而内核态可以执行的权限大，这个权限范围是由 CPU 控制的决定的，内核态的权限指令集是 <strong>Ring 0</strong>，用户态的权限指令集是 <strong>Ring 3</strong>，执行某些操作用户态没有权限完成，那么就是需要去调用内核态来执行这个命令，我们通过</strong>系统调用</strong>提供的接口来调用我们的内核态。下图是 Linux 操作系统的架构图。</p> <p>图中的几个概念理解：</p> <ul><li><h5 id="系统调用-using-syscalls"><a href="#系统调用-using-syscalls" class="header-anchor">#</a> 系统调用（using syscalls）</h5> <p>对底层硬件操作的封装，提供一组通用的访问接口</p></li> <li><h5 id="库函数"><a href="#库函数" class="header-anchor">#</a> 库函数</h5> <p>对底层复杂的接口的封装，向上层提供方便的调用接口</p></li> <li><h4 id="shell"><a href="#shell" class="header-anchor">#</a> Shell</h4> <p>命令行，脚本</p></li></ul> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ce300ee4c00000.png" alt="img"></p> <p>用户态可以执行的权限操作特别少，像是线程的创建、销毁以及定时器等这些不调用底层硬件的操作命令。所以程序的如果要正常执行，那么需要一个用户态线程绑定一个内核态线程，对于内核态，CPU 无法感知它的存在，从 CPU 的视角出发，它只能感知内核态的线程。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ce34d427400000.png" alt="8-线程的内核和用户态.png"></p> <p>它们都是线程，我们对它们进行的区分，用户态的线程叫作 <strong>协程（<code>Co-routine</code>）</strong>，内核态的线程还是叫作 <strong>线程（<code>Thread</code>）</strong>，线程由 CPU 负责调度，是<strong>抢占式</strong>的，也就是说一个线程不能允许一直被占用执行，最大允许时间是 10ms，超过时间就会被强制中断运行下一个线程，而协程是协作式的，由线程自己决定控制执行权。</p> <h3 id="_1-4-线程和协程映射关系"><a href="#_1-4-线程和协程映射关系" class="header-anchor">#</a> 1.4 线程和协程映射关系</h3> <ul><li>N:1 多个协程对应一个线程，但是如果有一个协程阻塞了，那么就是全部阻塞了；</li> <li>1:1 一个协程对应一个线程，如果这种资源代价贵；</li> <li>M:N 多个协程对应多个线程，实现起来比较复杂；</li></ul> <h3 id="_1-5-goroutine"><a href="#_1-5-goroutine" class="header-anchor">#</a> 1.5 goroutine</h3> <p><code>goroutine</code> 是 <code>Go</code> 语言中协程的概念，它非常的轻量，而且可以弹性伸缩，支持 4KB ~ 2GB 的内存范围，同时如果有阻塞，通过 <code>runtime</code> 可以调度其他协程执行。</p> <h2 id="二、gmp-调度器模型"><a href="#二、gmp-调度器模型" class="header-anchor">#</a> 二、GMP 调度器模型</h2> <h3 id="_2-1-早期的-gm-模型"><a href="#_2-1-早期的-gm-模型" class="header-anchor">#</a> 2.1 早期的 GM 模型</h3> <ul><li>G 表示 goroutine 协程</li> <li>M 表示 thread 内核态线程</li></ul> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ce59e504400000.png" alt="13-gm"></p> <p>所有待执行的 G 都存储在全局队列中，为保证资源竞争，会有一把互斥锁，每一次的创建、获取、销毁 G 都需要加锁。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ce5a7390800000.png" alt="14-old调度器.png"></p> <p>所以就会暴露出来几个问题：</p> <ul><li>全局一把锁，激烈的锁竞争，造成额外的资源浪费；</li> <li>系统调度的额外开销，G 和 M 的频繁切换；</li> <li>线程的局部性，G 创建的新线程 G2 会被随机的其他 M 执行，它们两个线程是相关的，最好应该在一个线程执行。</li></ul> <p>官方报告引述：</p> <blockquote><p><a href="http://code.google.com/p/vitess/wiki/Vtocc" target="_blank" rel="noopener noreferrer">Vtocc<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> server maxes out at 70% CPU on 8-core box, while profile shows 14% is spent in runtime.futex().</p> <p>Vtocc 服务器在8核机器上的CPU使用率最高达70%，而分析显示有14%的时间花费在 <code>runtime.futex()</code> 上。</p></blockquote> <h3 id="_2-2-gmp-模型"><a href="#_2-2-gmp-模型" class="header-anchor">#</a> 2.2 GMP 模型</h3> <p>现在的 GMP 模型如下图所示：</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ca73a870800000.png" alt="image-20240105135705824"></p> <ul><li><p>G groutine</p> <p>4KB ~ 2GB</p></li> <li><p>全局队列</p> <p>存放等待运行的 G，因为是全局共享的资源，有互斥锁。</p></li> <li><p>本地队列</p> <p>和一个执行器 P 绑定，存放本地将要被执行（也是等待运行，状态码是 <code>_Grunnable</code>）的 G，有限制，不超过256个，底层是 P 的一个字段，数据类型是 <code>[256]guintptr</code>；</p></li> <li><p>执行器 P</p> <p>负责将绑定的本地队列交给绑定的 M 执行的执行器，也存在互斥锁，但是影响不大；</p> <p>组成了一个执行器P列表，列表的执行器个数由 GOMAXPROCS 决定。</p> <p>一个 P 和一个 M 绑定，从 本地队列去获取 G来执行，但是 P 和 M 之间的数量没有绝对关系，当 M 执行的阻塞了，它会切换或者创建一个 M 绑定执行后面的 G。</p></li> <li><p>M 内核态线程</p> <p>内核态的线程。在 M 空闲或者阻塞的时候，它不需要 P，在运行 M 时，它必须绑定一个 P。</p> <p>M 和 M 相当于是有竞争的关系，M 的数量 &gt;= P 的数量，M 会去争取绑定一个 P，如果没有空闲的 P，那么 M 就会休眠，最后会垃圾回收。</p></li></ul> <h3 id="_2-3-设计策略"><a href="#_2-3-设计策略" class="header-anchor">#</a> 2.3 设计策略</h3> <h4 id="_1-复用策略"><a href="#_1-复用策略" class="header-anchor">#</a> 1. 复用策略</h4> <ul><li><p>偷取机制（work stealing）</p> <p>M 没有可以运行的 G ，P就去别的线程去获取可以执行的 G 来。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ca7dac19000000.jpg" alt="img"></p></li> <li><p>移交机制（Hand off）</p> <p>当前 M 阻塞了，P和本地队列会重新绑定到空闲的线程上面去。</p> <p>没有空闲的 M，就会去创建新的一个 M 然后绑定。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ca7f3483400000.jpg" alt="img"></p></li></ul> <h4 id="_2-利用并行"><a href="#_2-利用并行" class="header-anchor">#</a> 2. 利用并行</h4> <p>GOMAXPROCS 设置线程在多个 CPU 上同时运行。</p> <h4 id="_3-抢占"><a href="#_3-抢占" class="header-anchor">#</a> 3. 抢占</h4> <p>每个 G 每次最多只能占用 CPU 10ms时间，这个由 monitor g 来全局监控</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ca81acfe000000.png" alt="image-20240105145820462"></p> <h4 id="_4-全局队列"><a href="#_4-全局队列" class="header-anchor">#</a> 4. 全局队列</h4> <p>前面提到的偷取机制，如果本地队列为空时，先去全局队列获取执行，全局没有，就去别的 P  的本地队列获取 G 来运行。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/ca820055c00000.png" alt="image-20240105145946014"></p> <h3 id="_2-4-go-func-执行流程"><a href="#_2-4-go-func-执行流程" class="header-anchor">#</a> 2.4 go func 执行流程</h3> <ul><li><code>go</code> 关键字创建了一个新的 <code>goroutine</code>；</li> <li>优先放入<strong>本地队列</strong>，如果本地队列满了，再放入<strong>全局队列</strong>；</li> <li>M 循环执行本地队列的 G；</li> <li>如果本地队列为空，优先去全局队列取 G，全局队列是空的，那就去其他本地队列去取(working steal)。</li> <li>如果运行中遇到了 M 的阻塞，那么 P 就去绑定空闲或者创建新的线程；</li> <li>阻塞的 M 执行完 G 后，因为没有 P 没有和它绑定了，M 就休眠，G 放到全局队列。</li></ul> <h3 id="_2-5-生命周期"><a href="#_2-5-生命周期" class="header-anchor">#</a> 2.5 生命周期</h3> <ul><li>创建第一个线程 M0 和 G0，只负责初始化的一些操作，初始化之后，M0 变成普通的 M；</li> <li>每个 M 都有一个 G0，不参与代码的执行，只负责调度以及垃圾回收；</li> <li>初始化会创建预先设置好的 GOMAXPROCS  个 P，并且会绑定到 GOMAXPROCS  个 M 上面去；</li> <li>初始化创建主 goroutine，就是 mian.mian 函数，然后执行；</li> <li>一般情况下，main.main 在 M0 上面执行；</li> <li>如果在 M 执行过程中遇到了系统调用，那么此时会阻塞，与之绑定的 P 会绑定到别的空闲的 M 或者创建新的 M；</li> <li>当一个 G 被执行完，不会马上被销毁，而是会被放入到全局队列中，然后再等到调度器回收；</li></ul> <h2 id="三、执行过程分析"><a href="#三、执行过程分析" class="header-anchor">#</a> 三、执行过程分析</h2> <h3 id="_3-1-g1-创建-g2"><a href="#_3-1-g1-创建-g2" class="header-anchor">#</a> 3.1 G1 创建 G2</h3> <h4 id="_3-1-1-本队队列空间足够"><a href="#_3-1-1-本队队列空间足够" class="header-anchor">#</a> 3.1.1 本队队列空间足够</h4> <p>G1 创建了 G0，此时本地队列有足够的空间，为了保证<strong>局部性</strong>，那么就直接将 G2 放入和 G1 一起的本地队列；</p> <h4 id="_3-1-2-本地队列空间不足"><a href="#_3-1-2-本地队列空间不足" class="header-anchor">#</a> 3.1.2 本地队列空间不足</h4> <p>每个本地队列最多只能存放 256 个 G，如果本地队列放不下了，那么就需要执行负载均衡，把本地队列的前一半 G，以及新创建的 G2 放入全局队列，如果 G2在当前 G 之后就执行，则用某个老 G 替换放到全局队列，<strong>放入全局队列的顺序是被打散的</strong>。</p> <h3 id="_3-2-g0-调度"><a href="#_3-2-g0-调度" class="header-anchor">#</a> 3.2 G0 调度</h3> <h4 id="_3-2-1-本地队列有空闲-g"><a href="#_3-2-1-本地队列有空闲-g" class="header-anchor">#</a> 3.2.1 本地队列有空闲 G</h4> <p>G1 执行完毕或者执行 10ms之后，M执行的对象将切换为 G0，然后从绑定的 P 的本地队列获取下一个 G2，然后 G0 切换到 G2 继续执行，G0起到调度的作用。</p> <h4 id="_3-2-2-全局队列获取空闲-g"><a href="#_3-2-2-全局队列获取空闲-g" class="header-anchor">#</a> 3.2.2 全局队列获取空闲 G</h4> <p>如果本地队列没有空闲的 G，那么就会去全局队列偷取 G 来运行，偷取数量参考如下公式：</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code>n <span class="token operator">=</span>  <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>GQ<span class="token punctuation">)</span> <span class="token operator">/</span> GOMAXPROCS <span class="token operator">+</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token function">cap</span><span class="token punctuation">(</span>LQ<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_3-2-3-全局队列也没有空闲的-g"><a href="#_3-2-3-全局队列也没有空闲的-g" class="header-anchor">#</a> 3.2.3 全局队列也没有空闲的 G</h4> <p>如果全局队列也没有空闲的 G，就去其他队列偷取一般的 G 过来运行。</p> <h4 id="_3-2-4-没有空闲的-g"><a href="#_3-2-4-没有空闲的-g" class="header-anchor">#</a> 3.2.4 没有空闲的 G</h4> <p>如果都没有空闲的 G 了，那么 M 就处于<strong>自旋状态</strong>，不断尝试获取空闲的 G。因为 M 的创建、销毁也会损耗系统资源，但是只有绑定了 P 的 M 才能保持自旋状态，就是最多只能 <strong>GOMAXPROCS</strong> 个 M 自旋。</p> <h4 id="_3-2-4-网络轮旋"><a href="#_3-2-4-网络轮旋" class="header-anchor">#</a> 3.2.4 网络轮旋</h4> <p>看教程时，看到有评论说 P 获取 G 的顺序为：本地队列 -&gt; 全局队列 -&gt; 网络轮询 -&gt; 其它 P 队列偷取。</p> <p>网络轮询，后面再深入了解吧。</p> <p><img src="https://cdn-static.xxcheng.cn/static/uploads/d109f74cc00000.png" alt="image-20240110164439435"></p> <h3 id="_3-3-系统调用-syscall"><a href="#_3-3-系统调用-syscall" class="header-anchor">#</a> 3.3 系统调用（syscall）</h3> <p>如果 G1 进行了系统调用，<strong>无论阻塞还是非阻塞</strong>，都会导致当前绑定的 P 与 M 解绑，然后 P 绑定到新的 M 上面，当 G1 执行完后放入全局队列，M 休眠。</p> <h2 id="四、参考"><a href="#四、参考" class="header-anchor">#</a> 四、参考</h2> <ul><li><a href="https://juejin.cn/post/6923863670132850701" target="_blank" rel="noopener noreferrer">掘金 - 从根上理解用户态与内核态<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener noreferrer">知乎 - 怎样去理解Linux用户态和内核态？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.cnblogs.com/lisuyun/articles/3293580.html" target="_blank" rel="noopener noreferrer">博客园 - 线程和进程、程序、应用程序之间的关系<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.yuque.com/aceld/golang/srxd6d" target="_blank" rel="noopener noreferrer">Golang修养之路 - Golang的协程调度器原理及GMP设计思想<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://golang.org/s/go11sched" target="_blank" rel="noopener noreferrer">Scalable Go Scheduler Design Doc<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=GMP" title="标签">#GMP</a><a href="/tags/?tag=%E7%BA%BF%E7%A8%8B" title="标签">#线程</a><a href="/tags/?tag=%E5%8D%8F%E7%A8%8B" title="标签">#协程</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/01/10, 18:08:12</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/82ad4c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">rpc学习：进阶到gRPC</div></a> <a href="/pages/bb6d47/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">golang夯实基础第一天</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/82ad4c/" class="prev">rpc学习：进阶到gRPC</a></span> <span class="next"><a href="/pages/bb6d47/">golang夯实基础第一天</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/82ad4c/"><div>
            rpc学习：进阶到gRPC
            <!----></div></a> <span class="date">01-04</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/69ce89/"><div>
            配置
            <!----></div></a> <span class="date">12-12</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/57a155/"><div>
            子查询
            <!----></div></a> <span class="date">08-05</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:developer@xxcheng.cn" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/xxcheng" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://www.xxcheng.cn" title="首页" target="_blank" class="iconfont icon-mao"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2024
    <span>xxcheng | <a href="http://beian.miit.gov.cn" class="icpnum" target="_blank" rel="noreferrer">浙ICP备19024050号</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.93b3f0b1.js" defer></script><script src="/assets/js/2.aec7a7f0.js" defer></script><script src="/assets/js/14.eebbe75b.js" defer></script>
  </body>
</html>

(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{328:function(t,a,_){"use strict";_.r(a);var s=_(7),v=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、基础知识学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、基础知识学习"}},[t._v("#")]),t._v(" 一、基础知识学习")]),t._v(" "),a("h3",{attrs:{id:"_1-1-概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-概述"}},[t._v("#")]),t._v(" 1.1 概述")]),t._v(" "),a("p",[t._v("计算机最早是时候是单进程时代，一次只能执行一个进程任务，其他进程想执行任务，只能等待排队。")]),t._v(" "),a("p",[t._v("后面出现了多进程、多线程，可以同时执行多个进程/线程任务，但是这个是并非真正的同时执行。而是将CPU的执行时间切分成一个个时间单位（时间片），然后将这些进程/线程切换着执行。")]),t._v(" "),a("p",[t._v("如果一个进程资源很大，那么这个进程的创建、销毁、切换都会占用很大的时间，切换时会有切换成本。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ca3f3f0a400000.png",alt:"image-20240105100805883"}})]),t._v(" "),a("h3",{attrs:{id:"_1-2-进程和线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-进程和线程"}},[t._v("#")]),t._v(" 1.2 进程和线程")]),t._v(" "),a("p",[t._v("进程是"),a("strong",[t._v("资源分配")]),t._v("的基本单位，线程是"),a("strong",[t._v("调度和执行")]),t._v("的基本单位，一个进程下的多个线程共享内存资源，可以互相访问。但是多线程也存在着很多的问题：锁、资源竞争、同步。")]),t._v(" "),a("h3",{attrs:{id:"_1-3-内核态和用户态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-内核态和用户态"}},[t._v("#")]),t._v(" 1.3 内核态和用户态")]),t._v(" "),a("p",[t._v("这个知识点的概念我还是很模糊，只能结合几篇文章后来尝试表达我的理解。")]),t._v(" "),a("p",[t._v("首先"),a("strong",[t._v("内核态（Kernel Mode）"),a("strong",[t._v("和")]),t._v("用户态的（User Mode）"),a("strong",[t._v("主要的区别是执行的权限的不同，用户态可执行的权限小，而内核态可以执行的权限大，这个权限范围是由 CPU 控制的决定的，内核态的权限指令集是 "),a("strong",[t._v("Ring 0")]),t._v("，用户态的权限指令集是 "),a("strong",[t._v("Ring 3")]),t._v("，执行某些操作用户态没有权限完成，那么就是需要去调用内核态来执行这个命令，我们通过")]),t._v("系统调用")]),t._v("提供的接口来调用我们的内核态。下图是 Linux 操作系统的架构图。")]),t._v(" "),a("p",[t._v("图中的几个概念理解：")]),t._v(" "),a("ul",[a("li",[a("h5",{attrs:{id:"系统调用-using-syscalls"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统调用-using-syscalls"}},[t._v("#")]),t._v(" 系统调用（using syscalls）")]),t._v(" "),a("p",[t._v("对底层硬件操作的封装，提供一组通用的访问接口")])]),t._v(" "),a("li",[a("h5",{attrs:{id:"库函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#库函数"}},[t._v("#")]),t._v(" 库函数")]),t._v(" "),a("p",[t._v("对底层复杂的接口的封装，向上层提供方便的调用接口")])]),t._v(" "),a("li",[a("h4",{attrs:{id:"shell"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shell"}},[t._v("#")]),t._v(" Shell")]),t._v(" "),a("p",[t._v("命令行，脚本")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ce300ee4c00000.png",alt:"img"}})]),t._v(" "),a("p",[t._v("用户态可以执行的权限操作特别少，像是线程的创建、销毁以及定时器等这些不调用底层硬件的操作命令。所以程序的如果要正常执行，那么需要一个用户态线程绑定一个内核态线程，对于内核态，CPU 无法感知它的存在，从 CPU 的视角出发，它只能感知内核态的线程。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ce34d427400000.png",alt:"8-线程的内核和用户态.png"}})]),t._v(" "),a("p",[t._v("它们都是线程，我们对它们进行的区分，用户态的线程叫作 "),a("strong",[t._v("协程（"),a("code",[t._v("Co-routine")]),t._v("）")]),t._v("，内核态的线程还是叫作 "),a("strong",[t._v("线程（"),a("code",[t._v("Thread")]),t._v("）")]),t._v("，线程由 CPU 负责调度，是"),a("strong",[t._v("抢占式")]),t._v("的，也就是说一个线程不能允许一直被占用执行，最大允许时间是 10ms，超过时间就会被强制中断运行下一个线程，而协程是协作式的，由线程自己决定控制执行权。")]),t._v(" "),a("h3",{attrs:{id:"_1-4-线程和协程映射关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-线程和协程映射关系"}},[t._v("#")]),t._v(" 1.4 线程和协程映射关系")]),t._v(" "),a("ul",[a("li",[t._v("N:1 多个协程对应一个线程，但是如果有一个协程阻塞了，那么就是全部阻塞了；")]),t._v(" "),a("li",[t._v("1:1 一个协程对应一个线程，如果这种资源代价贵；")]),t._v(" "),a("li",[t._v("M:N 多个协程对应多个线程，实现起来比较复杂；")])]),t._v(" "),a("h3",{attrs:{id:"_1-5-goroutine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-goroutine"}},[t._v("#")]),t._v(" 1.5 goroutine")]),t._v(" "),a("p",[a("code",[t._v("goroutine")]),t._v(" 是 "),a("code",[t._v("Go")]),t._v(" 语言中协程的概念，它非常的轻量，而且可以弹性伸缩，支持 4KB ~ 2GB 的内存范围，同时如果有阻塞，通过 "),a("code",[t._v("runtime")]),t._v(" 可以调度其他协程执行。")]),t._v(" "),a("h2",{attrs:{id:"二、gmp-调度器模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、gmp-调度器模型"}},[t._v("#")]),t._v(" 二、GMP 调度器模型")]),t._v(" "),a("h3",{attrs:{id:"_2-1-早期的-gm-模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-早期的-gm-模型"}},[t._v("#")]),t._v(" 2.1 早期的 GM 模型")]),t._v(" "),a("ul",[a("li",[t._v("G 表示 goroutine 协程")]),t._v(" "),a("li",[t._v("M 表示 thread 内核态线程")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ce59e504400000.png",alt:"13-gm"}})]),t._v(" "),a("p",[t._v("所有待执行的 G 都存储在全局队列中，为保证资源竞争，会有一把互斥锁，每一次的创建、获取、销毁 G 都需要加锁。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ce5a7390800000.png",alt:"14-old调度器.png"}})]),t._v(" "),a("p",[t._v("所以就会暴露出来几个问题：")]),t._v(" "),a("ul",[a("li",[t._v("全局一把锁，激烈的锁竞争，造成额外的资源浪费；")]),t._v(" "),a("li",[t._v("系统调度的额外开销，G 和 M 的频繁切换；")]),t._v(" "),a("li",[t._v("线程的局部性，G 创建的新线程 G2 会被随机的其他 M 执行，它们两个线程是相关的，最好应该在一个线程执行。")])]),t._v(" "),a("p",[t._v("官方报告引述：")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"http://code.google.com/p/vitess/wiki/Vtocc",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vtocc"),a("OutboundLink")],1),t._v(" server maxes out at 70% CPU on 8-core box, while profile shows 14% is spent in runtime.futex().")]),t._v(" "),a("p",[t._v("Vtocc 服务器在8核机器上的CPU使用率最高达70%，而分析显示有14%的时间花费在 "),a("code",[t._v("runtime.futex()")]),t._v(" 上。")])]),t._v(" "),a("h3",{attrs:{id:"_2-2-gmp-模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-gmp-模型"}},[t._v("#")]),t._v(" 2.2 GMP 模型")]),t._v(" "),a("p",[t._v("现在的 GMP 模型如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ca73a870800000.png",alt:"image-20240105135705824"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("G groutine")]),t._v(" "),a("p",[t._v("4KB ~ 2GB")])]),t._v(" "),a("li",[a("p",[t._v("全局队列")]),t._v(" "),a("p",[t._v("存放等待运行的 G，因为是全局共享的资源，有互斥锁。")])]),t._v(" "),a("li",[a("p",[t._v("本地队列")]),t._v(" "),a("p",[t._v("和一个执行器 P 绑定，存放本地将要被执行（也是等待运行，状态码是 "),a("code",[t._v("_Grunnable")]),t._v("）的 G，有限制，不超过256个，底层是 P 的一个字段，数据类型是 "),a("code",[t._v("[256]guintptr")]),t._v("；")])]),t._v(" "),a("li",[a("p",[t._v("执行器 P")]),t._v(" "),a("p",[t._v("负责将绑定的本地队列交给绑定的 M 执行的执行器，也存在互斥锁，但是影响不大；")]),t._v(" "),a("p",[t._v("组成了一个执行器P列表，列表的执行器个数由 GOMAXPROCS 决定。")]),t._v(" "),a("p",[t._v("一个 P 和一个 M 绑定，从 本地队列去获取 G来执行，但是 P 和 M 之间的数量没有绝对关系，当 M 执行的阻塞了，它会切换或者创建一个 M 绑定执行后面的 G。")])]),t._v(" "),a("li",[a("p",[t._v("M 内核态线程")]),t._v(" "),a("p",[t._v("内核态的线程。在 M 空闲或者阻塞的时候，它不需要 P，在运行 M 时，它必须绑定一个 P。")]),t._v(" "),a("p",[t._v("M 和 M 相当于是有竞争的关系，M 的数量 >= P 的数量，M 会去争取绑定一个 P，如果没有空闲的 P，那么 M 就会休眠，最后会垃圾回收。")])])]),t._v(" "),a("h3",{attrs:{id:"_2-3-设计策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-设计策略"}},[t._v("#")]),t._v(" 2.3 设计策略")]),t._v(" "),a("h4",{attrs:{id:"_1-复用策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-复用策略"}},[t._v("#")]),t._v(" 1. 复用策略")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("偷取机制（work stealing）")]),t._v(" "),a("p",[t._v("M 没有可以运行的 G ，P就去别的线程去获取可以执行的 G 来。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ca7dac19000000.jpg",alt:"img"}})])]),t._v(" "),a("li",[a("p",[t._v("移交机制（Hand off）")]),t._v(" "),a("p",[t._v("当前 M 阻塞了，P和本地队列会重新绑定到空闲的线程上面去。")]),t._v(" "),a("p",[t._v("没有空闲的 M，就会去创建新的一个 M 然后绑定。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ca7f3483400000.jpg",alt:"img"}})])])]),t._v(" "),a("h4",{attrs:{id:"_2-利用并行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-利用并行"}},[t._v("#")]),t._v(" 2. 利用并行")]),t._v(" "),a("p",[t._v("GOMAXPROCS 设置线程在多个 CPU 上同时运行。")]),t._v(" "),a("h4",{attrs:{id:"_3-抢占"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-抢占"}},[t._v("#")]),t._v(" 3. 抢占")]),t._v(" "),a("p",[t._v("每个 G 每次最多只能占用 CPU 10ms时间，这个由 monitor g 来全局监控")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ca81acfe000000.png",alt:"image-20240105145820462"}})]),t._v(" "),a("h4",{attrs:{id:"_4-全局队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-全局队列"}},[t._v("#")]),t._v(" 4. 全局队列")]),t._v(" "),a("p",[t._v("前面提到的偷取机制，如果本地队列为空时，先去全局队列获取执行，全局没有，就去别的 P  的本地队列获取 G 来运行。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/ca820055c00000.png",alt:"image-20240105145946014"}})]),t._v(" "),a("h3",{attrs:{id:"_2-4-go-func-执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-go-func-执行流程"}},[t._v("#")]),t._v(" 2.4 go func 执行流程")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("go")]),t._v(" 关键字创建了一个新的 "),a("code",[t._v("goroutine")]),t._v("；")]),t._v(" "),a("li",[t._v("优先放入"),a("strong",[t._v("本地队列")]),t._v("，如果本地队列满了，再放入"),a("strong",[t._v("全局队列")]),t._v("；")]),t._v(" "),a("li",[t._v("M 循环执行本地队列的 G；")]),t._v(" "),a("li",[t._v("如果本地队列为空，优先去全局队列取 G，全局队列是空的，那就去其他本地队列去取(working steal)。")]),t._v(" "),a("li",[t._v("如果运行中遇到了 M 的阻塞，那么 P 就去绑定空闲或者创建新的线程；")]),t._v(" "),a("li",[t._v("阻塞的 M 执行完 G 后，因为没有 P 没有和它绑定了，M 就休眠，G 放到全局队列。")])]),t._v(" "),a("h3",{attrs:{id:"_2-5-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-生命周期"}},[t._v("#")]),t._v(" 2.5 生命周期")]),t._v(" "),a("ul",[a("li",[t._v("创建第一个线程 M0 和 G0，只负责初始化的一些操作，初始化之后，M0 变成普通的 M；")]),t._v(" "),a("li",[t._v("每个 M 都有一个 G0，不参与代码的执行，只负责调度以及垃圾回收；")]),t._v(" "),a("li",[t._v("初始化会创建预先设置好的 GOMAXPROCS  个 P，并且会绑定到 GOMAXPROCS  个 M 上面去；")]),t._v(" "),a("li",[t._v("初始化创建主 goroutine，就是 mian.mian 函数，然后执行；")]),t._v(" "),a("li",[t._v("一般情况下，main.main 在 M0 上面执行；")]),t._v(" "),a("li",[t._v("如果在 M 执行过程中遇到了系统调用，那么此时会阻塞，与之绑定的 P 会绑定到别的空闲的 M 或者创建新的 M；")]),t._v(" "),a("li",[t._v("当一个 G 被执行完，不会马上被销毁，而是会被放入到全局队列中，然后再等到调度器回收；")])]),t._v(" "),a("h2",{attrs:{id:"三、执行过程分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、执行过程分析"}},[t._v("#")]),t._v(" 三、执行过程分析")]),t._v(" "),a("h3",{attrs:{id:"_3-1-g1-创建-g2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-g1-创建-g2"}},[t._v("#")]),t._v(" 3.1 G1 创建 G2")]),t._v(" "),a("h4",{attrs:{id:"_3-1-1-本队队列空间足够"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-本队队列空间足够"}},[t._v("#")]),t._v(" 3.1.1 本队队列空间足够")]),t._v(" "),a("p",[t._v("G1 创建了 G0，此时本地队列有足够的空间，为了保证"),a("strong",[t._v("局部性")]),t._v("，那么就直接将 G2 放入和 G1 一起的本地队列；")]),t._v(" "),a("h4",{attrs:{id:"_3-1-2-本地队列空间不足"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-本地队列空间不足"}},[t._v("#")]),t._v(" 3.1.2 本地队列空间不足")]),t._v(" "),a("p",[t._v("每个本地队列最多只能存放 256 个 G，如果本地队列放不下了，那么就需要执行负载均衡，把本地队列的前一半 G，以及新创建的 G2 放入全局队列，如果 G2在当前 G 之后就执行，则用某个老 G 替换放到全局队列，"),a("strong",[t._v("放入全局队列的顺序是被打散的")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"_3-2-g0-调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-g0-调度"}},[t._v("#")]),t._v(" 3.2 G0 调度")]),t._v(" "),a("h4",{attrs:{id:"_3-2-1-本地队列有空闲-g"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-本地队列有空闲-g"}},[t._v("#")]),t._v(" 3.2.1 本地队列有空闲 G")]),t._v(" "),a("p",[t._v("G1 执行完毕或者执行 10ms之后，M执行的对象将切换为 G0，然后从绑定的 P 的本地队列获取下一个 G2，然后 G0 切换到 G2 继续执行，G0起到调度的作用。")]),t._v(" "),a("h4",{attrs:{id:"_3-2-2-全局队列获取空闲-g"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-2-全局队列获取空闲-g"}},[t._v("#")]),t._v(" 3.2.2 全局队列获取空闲 G")]),t._v(" "),a("p",[t._v("如果本地队列没有空闲的 G，那么就会去全局队列偷取 G 来运行，偷取数量参考如下公式：")]),t._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[t._v("n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("min")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("GQ"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" GOMAXPROCS "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LQ"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h4",{attrs:{id:"_3-2-3-全局队列也没有空闲的-g"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-3-全局队列也没有空闲的-g"}},[t._v("#")]),t._v(" 3.2.3 全局队列也没有空闲的 G")]),t._v(" "),a("p",[t._v("如果全局队列也没有空闲的 G，就去其他队列偷取一般的 G 过来运行。")]),t._v(" "),a("h4",{attrs:{id:"_3-2-4-没有空闲的-g"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-没有空闲的-g"}},[t._v("#")]),t._v(" 3.2.4 没有空闲的 G")]),t._v(" "),a("p",[t._v("如果都没有空闲的 G 了，那么 M 就处于"),a("strong",[t._v("自旋状态")]),t._v("，不断尝试获取空闲的 G。因为 M 的创建、销毁也会损耗系统资源，但是只有绑定了 P 的 M 才能保持自旋状态，就是最多只能 "),a("strong",[t._v("GOMAXPROCS")]),t._v(" 个 M 自旋。")]),t._v(" "),a("h4",{attrs:{id:"_3-2-4-网络轮旋"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-4-网络轮旋"}},[t._v("#")]),t._v(" 3.2.4 网络轮旋")]),t._v(" "),a("p",[t._v("看教程时，看到有评论说 P 获取 G 的顺序为：本地队列 -> 全局队列 -> 网络轮询 -> 其它 P 队列偷取。")]),t._v(" "),a("p",[t._v("网络轮询，后面再深入了解吧。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-static.xxcheng.cn/static/uploads/d109f74cc00000.png",alt:"image-20240110164439435"}})]),t._v(" "),a("h3",{attrs:{id:"_3-3-系统调用-syscall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-系统调用-syscall"}},[t._v("#")]),t._v(" 3.3 系统调用（syscall）")]),t._v(" "),a("p",[t._v("如果 G1 进行了系统调用，"),a("strong",[t._v("无论阻塞还是非阻塞")]),t._v("，都会导致当前绑定的 P 与 M 解绑，然后 P 绑定到新的 M 上面，当 G1 执行完后放入全局队列，M 休眠。")]),t._v(" "),a("h2",{attrs:{id:"四、参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、参考"}},[t._v("#")]),t._v(" 四、参考")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6923863670132850701",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金 - 从根上理解用户态与内核态"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/69554144",target:"_blank",rel:"noopener noreferrer"}},[t._v("知乎 - 怎样去理解Linux用户态和内核态？"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.cnblogs.com/lisuyun/articles/3293580.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("博客园 - 线程和进程、程序、应用程序之间的关系"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.yuque.com/aceld/golang/srxd6d",target:"_blank",rel:"noopener noreferrer"}},[t._v("Golang修养之路 - Golang的协程调度器原理及GMP设计思想"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://golang.org/s/go11sched",target:"_blank",rel:"noopener noreferrer"}},[t._v("Scalable Go Scheduler Design Doc"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=v.exports}}]);